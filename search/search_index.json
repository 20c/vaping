{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vaping vaping is a healthy alternative to smokeping!* (This statement has not been evaluated by the Food and Drug Administration) Introduction Vaping provides the following features: Real-time latency graphing viewable in the browser Line and smokestack graphs Containerized and easy to setup and configure Support for time-series databases Plugin-based design to allow integration with other services Supports distributed setups through message queue Vaping is a Python daemon which polls for input and sends its output through plugins. It has a standalone mode to directly serve realtime graphs in a browser, or can use ZeroMQ to distribute messages. Installation pip install vaping You will need a compiler and Python development libraries for some components, which you can obtain with the gcc and python-devel packages for your operating system. Alternatively, you can use the Docker image , which includes all requirements. Quick Start To use Vaping, you need first a configuration file that defines which hosts to target and where to send the output. You can have a look at the examples in this repository and adapt them to your needs. Then, start the vaping program from the command line, specifying the path to the configuration file. A quick start example is available here . It shows you how to ping multiple hosts and display the resulting graphs using a local web server. Usage Vaping has a command-line interface with the following usage: Usage: vaping [OPTIONS] COMMAND [ARGS]... Vaping Options: --version Show the version and exit. --quiet no output at all --verbose enable more verbose output --home TEXT specify the home directory, by default will check in order: $VAPING_HOME, ./.vaping, ~/.config/vaping --debug enable extra debug output --help Show this message and exit. Commands: start start a vaping process stop stop a vaping process restart restart a vaping process start Starts a vaping process, by default will fork into the background unless --debug or --no-fork is passed. It adds options: -d, --no-fork do not fork into background stop Stops a vaping process identified by $VAPING_HOME/vaping.pid Documentation Documentation is created with mkdocs and available here: stable : http://vaping.readthedocs.io/en/stable/ latest : http://vaping.readthedocs.io/en/latest/ Changes The current change log is available at https://github.com/20c/vaping/blob/master/CHANGELOG.md License Copyright 2016-2021 20C, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this software except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Home"},{"location":"#vaping","text":"vaping is a healthy alternative to smokeping!* (This statement has not been evaluated by the Food and Drug Administration)","title":"Vaping"},{"location":"#introduction","text":"Vaping provides the following features: Real-time latency graphing viewable in the browser Line and smokestack graphs Containerized and easy to setup and configure Support for time-series databases Plugin-based design to allow integration with other services Supports distributed setups through message queue Vaping is a Python daemon which polls for input and sends its output through plugins. It has a standalone mode to directly serve realtime graphs in a browser, or can use ZeroMQ to distribute messages.","title":"Introduction"},{"location":"#installation","text":"pip install vaping You will need a compiler and Python development libraries for some components, which you can obtain with the gcc and python-devel packages for your operating system. Alternatively, you can use the Docker image , which includes all requirements.","title":"Installation"},{"location":"#quick-start","text":"To use Vaping, you need first a configuration file that defines which hosts to target and where to send the output. You can have a look at the examples in this repository and adapt them to your needs. Then, start the vaping program from the command line, specifying the path to the configuration file. A quick start example is available here . It shows you how to ping multiple hosts and display the resulting graphs using a local web server.","title":"Quick Start"},{"location":"#usage","text":"Vaping has a command-line interface with the following usage: Usage: vaping [OPTIONS] COMMAND [ARGS]... Vaping Options: --version Show the version and exit. --quiet no output at all --verbose enable more verbose output --home TEXT specify the home directory, by default will check in order: $VAPING_HOME, ./.vaping, ~/.config/vaping --debug enable extra debug output --help Show this message and exit. Commands: start start a vaping process stop stop a vaping process restart restart a vaping process","title":"Usage"},{"location":"#start","text":"Starts a vaping process, by default will fork into the background unless --debug or --no-fork is passed. It adds options: -d, --no-fork do not fork into background","title":"start"},{"location":"#stop","text":"Stops a vaping process identified by $VAPING_HOME/vaping.pid","title":"stop"},{"location":"#documentation","text":"Documentation is created with mkdocs and available here: stable : http://vaping.readthedocs.io/en/stable/ latest : http://vaping.readthedocs.io/en/latest/","title":"Documentation"},{"location":"#changes","text":"The current change log is available at https://github.com/20c/vaping/blob/master/CHANGELOG.md","title":"Changes"},{"location":"#license","text":"Copyright 2016-2021 20C, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this software except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"config/","text":"Introduction Vaping will look for its config directory in the following order: command line option --home environment variable $VAPING_HOME .vaping in the current working directory $APP_DIR/vaping ( .config/vaping/ or .vaping/ on most systems). By default it uses YAML config files, but will also support JSON, which it determines by file extension, for example $VAPING_HOME/config.yml Default Config vaping: pidfile: vaping.pid plugin_path: [] probes: plugins: Plugins The plugins section is a list defining which plugins are loaded and possibly configured to share between anything else referencing it. Each must define type , which can either be a plugin type, or the name of a previously defined type. To reference it later, name must be defined. fping command command to run interval time between pings count number of pings to send period time in milliseconds that fping waits between successive packets to an individual target For example, the default of interval: 1m count: 5 period: 20 sends 5 pings to each host every minute, with 20 milliseconds between each one. whisper Config options for whisper plugin: retention is a list of $time_per_data_point:$length_to_store filename is the path/name of the file you'd like to write the data to field is the values you want to retrieve from. i.e. avg, max, min Variables: source - the probe the data will be received from host - the IP/FQDN of the host being monitored field - the field being written to whisper For example: plugins: - name: whisper_avg type: whisper # will create one file per host # for example: latency-8.8.8.8-avg filename: '{source}-{host}-{field}.wsp' # specified which field to retrieve the value from field: avg # whisper configuration aggregation_method: average sparse: false x_files_factor: 0.5 retention: - 60:1440 # 60 seconds per datapoint, 1440 datapoints = 1 day of retention - 15m:8 # 15 minutes per datapoint, 8 datapoints = 2 hours of retention - 1h:7d # 1 hour per datapoint, 7 days of retention - 12h:2y # 12 hours per datapoint, 2 years of retention Full example: examples/whisper/config.yml Probes The probes section is a list defining input sections. It must define at least type which may refer directly to a plugin type, or to a config defined type. Probes may not use the same name as any plugin. The probes section also contains output , which is a list of plugins for sending results to another service like zeromq or whisper database. Example: probes: - name: latency type: std_fping output: - whisper_avg - zmq_vodka Custom Layouts - Graphsrv It is possible for you to add / edit your layouts. You can use this to add additional rows/columns to the display grid. Basic Layout example: Create a layout.yml file. layouts: ## INDEX ##################################################################### index: type: index grid: 3x3 graph: config: multitarget fit: \"yes\" targets: all ## DETAIL #################################################################### detail: type: custom layout: # row 1 - cols: # col 1, render a graph - graph: config: multitarget # fit to column fit: \"yes\" # render all targets to this graph targets: all # custom graph id id: multitarget-1 width: 12 height: 100 Add mapping to the apps.graphsrv section pointing to the layout file. apps: graphsrv: enabled: true layout_config_file: ./layout.yml For more information, see graphsrv's documentation on the subject at https://graphsrv.readthedocs.io/en/latest/custom/#layout","title":"Configuration"},{"location":"config/#introduction","text":"Vaping will look for its config directory in the following order: command line option --home environment variable $VAPING_HOME .vaping in the current working directory $APP_DIR/vaping ( .config/vaping/ or .vaping/ on most systems). By default it uses YAML config files, but will also support JSON, which it determines by file extension, for example $VAPING_HOME/config.yml","title":"Introduction"},{"location":"config/#default-config","text":"vaping: pidfile: vaping.pid plugin_path: [] probes: plugins:","title":"Default Config"},{"location":"config/#plugins","text":"The plugins section is a list defining which plugins are loaded and possibly configured to share between anything else referencing it. Each must define type , which can either be a plugin type, or the name of a previously defined type. To reference it later, name must be defined.","title":"Plugins"},{"location":"config/#fping","text":"command command to run interval time between pings count number of pings to send period time in milliseconds that fping waits between successive packets to an individual target For example, the default of interval: 1m count: 5 period: 20 sends 5 pings to each host every minute, with 20 milliseconds between each one.","title":"fping"},{"location":"config/#whisper","text":"Config options for whisper plugin: retention is a list of $time_per_data_point:$length_to_store filename is the path/name of the file you'd like to write the data to field is the values you want to retrieve from. i.e. avg, max, min Variables: source - the probe the data will be received from host - the IP/FQDN of the host being monitored field - the field being written to whisper For example: plugins: - name: whisper_avg type: whisper # will create one file per host # for example: latency-8.8.8.8-avg filename: '{source}-{host}-{field}.wsp' # specified which field to retrieve the value from field: avg # whisper configuration aggregation_method: average sparse: false x_files_factor: 0.5 retention: - 60:1440 # 60 seconds per datapoint, 1440 datapoints = 1 day of retention - 15m:8 # 15 minutes per datapoint, 8 datapoints = 2 hours of retention - 1h:7d # 1 hour per datapoint, 7 days of retention - 12h:2y # 12 hours per datapoint, 2 years of retention Full example: examples/whisper/config.yml","title":"whisper"},{"location":"config/#probes","text":"The probes section is a list defining input sections. It must define at least type which may refer directly to a plugin type, or to a config defined type. Probes may not use the same name as any plugin. The probes section also contains output , which is a list of plugins for sending results to another service like zeromq or whisper database. Example: probes: - name: latency type: std_fping output: - whisper_avg - zmq_vodka","title":"Probes"},{"location":"config/#custom-layouts-graphsrv","text":"It is possible for you to add / edit your layouts. You can use this to add additional rows/columns to the display grid.","title":"Custom Layouts - Graphsrv"},{"location":"config/#basic-layout-example","text":"Create a layout.yml file. layouts: ## INDEX ##################################################################### index: type: index grid: 3x3 graph: config: multitarget fit: \"yes\" targets: all ## DETAIL #################################################################### detail: type: custom layout: # row 1 - cols: # col 1, render a graph - graph: config: multitarget # fit to column fit: \"yes\" # render all targets to this graph targets: all # custom graph id id: multitarget-1 width: 12 height: 100 Add mapping to the apps.graphsrv section pointing to the layout file. apps: graphsrv: enabled: true layout_config_file: ./layout.yml For more information, see graphsrv's documentation on the subject at https://graphsrv.readthedocs.io/en/latest/custom/#layout","title":"Basic Layout example:"},{"location":"container/","text":"Vaping Dockerfile The base Dockerfile will build an alpine image containing: a python 3.7 virtual environment containing vaping at /venv/ the vaping examples at /app/examples To build the image Build args dep_packages - OS packages to install (default: fping ) virtual_env - What image directory to install the virtual env into (default: /venv ) vaping_home - What vaping should use as a --home directory (default: /app/examples/standalone_dns ) vaping_uid - What user id to run vaping as (default: 1000 ) docker build -t vaping:$(cat Ctl/VERSION) --build-arg=vaping_uid=1002 . To run the image Environment variables VAPING_HOME - What vaping should use as a --home directory Docker command By default, it exposes port 7021, so: docker run -p 7021:7021 -it --rm vaping:$(cat Ctl/VERSION)","title":"Vaping Dockerfile"},{"location":"container/#vaping-dockerfile","text":"The base Dockerfile will build an alpine image containing: a python 3.7 virtual environment containing vaping at /venv/ the vaping examples at /app/examples","title":"Vaping Dockerfile"},{"location":"container/#to-build-the-image","text":"","title":"To build the image"},{"location":"container/#build-args","text":"dep_packages - OS packages to install (default: fping ) virtual_env - What image directory to install the virtual env into (default: /venv ) vaping_home - What vaping should use as a --home directory (default: /app/examples/standalone_dns ) vaping_uid - What user id to run vaping as (default: 1000 ) docker build -t vaping:$(cat Ctl/VERSION) --build-arg=vaping_uid=1002 .","title":"Build args"},{"location":"container/#to-run-the-image","text":"","title":"To run the image"},{"location":"container/#environment-variables","text":"VAPING_HOME - What vaping should use as a --home directory","title":"Environment variables"},{"location":"container/#docker-command","text":"By default, it exposes port 7021, so: docker run -p 7021:7021 -it --rm vaping:$(cat Ctl/VERSION)","title":"Docker command"},{"location":"dev/","text":"Plugins It is not difficult to write plugins for vaping, just inherit from the type you want to make and put it in the $VAPING_HOME/plugins directory. To make a probe that executes at a user configurable time like fping, simply import vaping, @register it's name, inherit from vaping.plugins.TimedProbe , and define probe() . Vaping will take care of the rest, including threading and IO multiplexing. For example, create the following at $VAPING_HOME/plugins/plugin_name.py : import vaping @vaping.plugin.register('plugin_name') class FPing(vaping.plugins.TimedProbe): # called when the class is instantiated def init(self): pass # called when it needs data def probe(self): return [] Then to use it, in your config file, add: probes: - name: new probe type: plugin_name interval: 3s output: - web And Vaping will call probe() every 3 seconds. Classes PluginBase PluginBase(vaping.io.Thread) Base plugin class Initializes: self.config as plugins config self.log as a logging object for plugin self.vaping as a reference to the main vaping object Then calls alls self.init() prefork while loading all modules, init() should not do anything active, any files opened may be closed when it forks. Plugins should prefer init() to __init__() to ensure the class is completely done initializing. Calls self.on_start() and self.on_stop() before and after running in case any connections need to be created or cleaned up. init init(self) called after the plugin is initialized, plugin may define this for any other initialization code on_start on_start(self) called when the daemon is starting on_stop on_stop(self) called when the daemon is stopping new_message new_message(self) creates a new message, setting type , source , ts , data - data is initialized to an empty array popen popen(self, args, **kwargs) creates a subprocess with passed args ProbeBase ProbeBase(vaping.plugins.PluginBase) Base class for probe plugin, used for getting data expects method probe() to be defined probe probe(self) probe for data, return a list of dicts TimedProbe TimedProbe(vaping.plugins.ProbeBase) Probe class that calls probe every config defined interval EmitBase EmitBase(vaping.plugins.PluginBase) Base class for emit plugins, used for sending data expects method emit() to be defined emit emit(self, message) accept message to emit","title":"Development"},{"location":"dev/#_1","text":"","title":""},{"location":"dev/#plugins","text":"It is not difficult to write plugins for vaping, just inherit from the type you want to make and put it in the $VAPING_HOME/plugins directory. To make a probe that executes at a user configurable time like fping, simply import vaping, @register it's name, inherit from vaping.plugins.TimedProbe , and define probe() . Vaping will take care of the rest, including threading and IO multiplexing. For example, create the following at $VAPING_HOME/plugins/plugin_name.py : import vaping @vaping.plugin.register('plugin_name') class FPing(vaping.plugins.TimedProbe): # called when the class is instantiated def init(self): pass # called when it needs data def probe(self): return [] Then to use it, in your config file, add: probes: - name: new probe type: plugin_name interval: 3s output: - web And Vaping will call probe() every 3 seconds.","title":"Plugins"},{"location":"dev/#classes","text":"","title":"Classes"},{"location":"dev/#pluginbase","text":"PluginBase(vaping.io.Thread) Base plugin class Initializes: self.config as plugins config self.log as a logging object for plugin self.vaping as a reference to the main vaping object Then calls alls self.init() prefork while loading all modules, init() should not do anything active, any files opened may be closed when it forks. Plugins should prefer init() to __init__() to ensure the class is completely done initializing. Calls self.on_start() and self.on_stop() before and after running in case any connections need to be created or cleaned up.","title":"PluginBase"},{"location":"dev/#init","text":"init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"dev/#on_start","text":"on_start(self) called when the daemon is starting","title":"on_start"},{"location":"dev/#on_stop","text":"on_stop(self) called when the daemon is stopping","title":"on_stop"},{"location":"dev/#new_message","text":"new_message(self) creates a new message, setting type , source , ts , data - data is initialized to an empty array","title":"new_message"},{"location":"dev/#popen","text":"popen(self, args, **kwargs) creates a subprocess with passed args","title":"popen"},{"location":"dev/#probebase","text":"ProbeBase(vaping.plugins.PluginBase) Base class for probe plugin, used for getting data expects method probe() to be defined","title":"ProbeBase"},{"location":"dev/#probe","text":"probe(self) probe for data, return a list of dicts","title":"probe"},{"location":"dev/#timedprobe","text":"TimedProbe(vaping.plugins.ProbeBase) Probe class that calls probe every config defined interval","title":"TimedProbe"},{"location":"dev/#emitbase","text":"EmitBase(vaping.plugins.PluginBase) Base class for emit plugins, used for sending data expects method emit() to be defined","title":"EmitBase"},{"location":"dev/#emit","text":"emit(self, message) accept message to emit","title":"emit"},{"location":"examples/","text":"Two distributed vaping instances on the same graph This example shows how two run 2 separate vaping instances connected to a vodka instance and plot on the same graph. Running a distributed setup For a complete understanding of running a distributed vaping setup, please read the Distributed Latency example in the quickstart section. Requires vodka 2.2.6 This requires that you install vodka 2.2.6 or higher: pip install vodka>=2.2.6 Vaping instance 1 - this one will ping 1.1.1.1 examples/distributed_shared_graph/vaping-1/config.yml : probes: - name: latency type: std_fping output: - zmq_vodka groups: - name: public_dns hosts: - host: 1.1.1.1 plugins: - name: std_fping type: fping count: 10 interval: 3s - name: zmq_vodka type: zeromq bind: tcp://127.0.0.1:6021 logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vaping start --home=examples/distributed_shared_graph/vaping-1 --debug Vaping instance 2 - this one will ping 8.8.8.8 examples/distributed_shared_graph/vaping-2/config.yml : probes: - name: latency type: std_fping output: - zmq_vodka groups: - name: public_dns hosts: - host: 8.8.8.8 plugins: - name: std_fping type: fping count: 10 interval: 3s - name: zmq_vodka type: zeromq bind: tcp://127.0.0.1:6022 logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vaping start --home=examples/distributed_shared_graph/vaping-2 --debug Vodka examples/distributed_shared_graph/vodka/config.yml : data: - type: fping handlers: - type: index index: host - type: store container: list limit: 500 apps: graphsrv: enabled: true # here is where we define host config groups: latency: public_dns: 8.8.8.8: name: Google color: red 1.1.1.1: name: Cloudflare color: blue graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg plugins: # zero mq probe plugin to vaping-1 instance # (latency name is important, so it can be routed properly to # the similarly named group) - name: latency type: zeromq_probe data: fping interval: 1.0 bind: tcp://127.0.0.1:6021 async: thread # zero mq probe plugin to vaping-2 instance # We cannot have duplicate names so we name it `latency2` # However we still want it to get collected to `latency` # We will do that using the `data_id` config - name: latency_2 type: zeromq_probe data_id: latency data: fping interval: 1.0 bind: tcp://127.0.0.1:6022 async: thread - name: http type: flask bind: 0.0.0.0:7021 debug: true # set this to gunicorn or uwsgi depending on what you want to run with server: gunicorn async: gevent routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout loggers: vodka: level: DEBUG handlers: - console export VODKA_HOME=examples/distributed_shared_graph/vodka gunicorn -b 0.0.0.0:7021 vodka.runners.wsgi:application MTR This example will show you how to setup an MTR graph: Requires graphsrv 1.3.0 You need to run graphsrv 1.3.0 or later in order to be able to render MTR graphs. pip install graphsrv>=1.3.0 Requires traceroute We use the traceroute command to determine the hops to send to fping. Make sure it is installed. MTR Graph is currently experimental The MTR graph is introduced to vaping in version 0.6.0 and should be considered an early iteration of MTR data visualization to vaping. We have ideas on how to make it better, but would also love to hear your thoughts on it. Pay close attention to the commented lines in the example below, as you need to do the following: setup the mtr probe setup the fping_mtr plugin setup the fping_mtr data type setup the mtr graph examples/mtr/config.yml : probes: # mtr probe - name: mtr type: fping_mtr # we need to let graphsrv know what the default # graph to render data from this probe should be, # in this case we want it to be `mtr` default_graph: mtr # we need to let graphsrv know what data group # to use for data from this probe. Since the probe # itself is not setting up any groups unlike the `fping` # probe. group: mtr.cloudflare_dns # target host for the mtr probe host: 1.1.1.1 output: - vodka plugins: # mtr plugin - name: fping_mtr type: fping_mtr interval: 3s - name: vodka type: vodka data: # We have to add a new data type to handle mtr data - type: fping_mtr handlers: - type: index index: host - type: store container: list limit: 100 apps: graphsrv: enabled: true graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg # let graphsrv know to initialize the `mtr` # graph for use mtr: id_field: host type: mtr plugins: - name: http type: flask bind: 0.0.0.0:7021 debug: true static_url_path: /static server: self async: thread routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vodka: level: DEBUG handlers: - console #- file vaping start --home=examples/mtr --debug MTR - Distributed When setting up a distributed MTR probe, the group on the vodka end should be setup like this: apps: graphsrv: enabled: true groups: mtr: config: default_graph: mtr cloudflare_dns: 1.1.1.1: name: Cloudflare color: mediumpurple","title":"Advanced Examples"},{"location":"examples/#two-distributed-vaping-instances-on-the-same-graph","text":"This example shows how two run 2 separate vaping instances connected to a vodka instance and plot on the same graph. Running a distributed setup For a complete understanding of running a distributed vaping setup, please read the Distributed Latency example in the quickstart section. Requires vodka 2.2.6 This requires that you install vodka 2.2.6 or higher: pip install vodka>=2.2.6 Vaping instance 1 - this one will ping 1.1.1.1 examples/distributed_shared_graph/vaping-1/config.yml : probes: - name: latency type: std_fping output: - zmq_vodka groups: - name: public_dns hosts: - host: 1.1.1.1 plugins: - name: std_fping type: fping count: 10 interval: 3s - name: zmq_vodka type: zeromq bind: tcp://127.0.0.1:6021 logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vaping start --home=examples/distributed_shared_graph/vaping-1 --debug Vaping instance 2 - this one will ping 8.8.8.8 examples/distributed_shared_graph/vaping-2/config.yml : probes: - name: latency type: std_fping output: - zmq_vodka groups: - name: public_dns hosts: - host: 8.8.8.8 plugins: - name: std_fping type: fping count: 10 interval: 3s - name: zmq_vodka type: zeromq bind: tcp://127.0.0.1:6022 logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vaping start --home=examples/distributed_shared_graph/vaping-2 --debug Vodka examples/distributed_shared_graph/vodka/config.yml : data: - type: fping handlers: - type: index index: host - type: store container: list limit: 500 apps: graphsrv: enabled: true # here is where we define host config groups: latency: public_dns: 8.8.8.8: name: Google color: red 1.1.1.1: name: Cloudflare color: blue graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg plugins: # zero mq probe plugin to vaping-1 instance # (latency name is important, so it can be routed properly to # the similarly named group) - name: latency type: zeromq_probe data: fping interval: 1.0 bind: tcp://127.0.0.1:6021 async: thread # zero mq probe plugin to vaping-2 instance # We cannot have duplicate names so we name it `latency2` # However we still want it to get collected to `latency` # We will do that using the `data_id` config - name: latency_2 type: zeromq_probe data_id: latency data: fping interval: 1.0 bind: tcp://127.0.0.1:6022 async: thread - name: http type: flask bind: 0.0.0.0:7021 debug: true # set this to gunicorn or uwsgi depending on what you want to run with server: gunicorn async: gevent routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout loggers: vodka: level: DEBUG handlers: - console export VODKA_HOME=examples/distributed_shared_graph/vodka gunicorn -b 0.0.0.0:7021 vodka.runners.wsgi:application","title":"Two distributed vaping instances on the same graph"},{"location":"examples/#mtr","text":"This example will show you how to setup an MTR graph: Requires graphsrv 1.3.0 You need to run graphsrv 1.3.0 or later in order to be able to render MTR graphs. pip install graphsrv>=1.3.0 Requires traceroute We use the traceroute command to determine the hops to send to fping. Make sure it is installed. MTR Graph is currently experimental The MTR graph is introduced to vaping in version 0.6.0 and should be considered an early iteration of MTR data visualization to vaping. We have ideas on how to make it better, but would also love to hear your thoughts on it. Pay close attention to the commented lines in the example below, as you need to do the following: setup the mtr probe setup the fping_mtr plugin setup the fping_mtr data type setup the mtr graph examples/mtr/config.yml : probes: # mtr probe - name: mtr type: fping_mtr # we need to let graphsrv know what the default # graph to render data from this probe should be, # in this case we want it to be `mtr` default_graph: mtr # we need to let graphsrv know what data group # to use for data from this probe. Since the probe # itself is not setting up any groups unlike the `fping` # probe. group: mtr.cloudflare_dns # target host for the mtr probe host: 1.1.1.1 output: - vodka plugins: # mtr plugin - name: fping_mtr type: fping_mtr interval: 3s - name: vodka type: vodka data: # We have to add a new data type to handle mtr data - type: fping_mtr handlers: - type: index index: host - type: store container: list limit: 100 apps: graphsrv: enabled: true graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg # let graphsrv know to initialize the `mtr` # graph for use mtr: id_field: host type: mtr plugins: - name: http type: flask bind: 0.0.0.0:7021 debug: true static_url_path: /static server: self async: thread routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vodka: level: DEBUG handlers: - console #- file vaping start --home=examples/mtr --debug MTR - Distributed When setting up a distributed MTR probe, the group on the vodka end should be setup like this: apps: graphsrv: enabled: true groups: mtr: config: default_graph: mtr cloudflare_dns: 1.1.1.1: name: Cloudflare color: mediumpurple","title":"MTR"},{"location":"layout/","text":"Customize Layout Vaping allows users to customize its layout by supplying a new layout config file. In the example below, the detail layout is changed to show 4 smokestack graphs instead of 3. Working directory matters for this example To test example below, please execute the command from the vaping root directory. The example provides a relative path to the layout file and will not find it otherwise. vaping start --home=examples/custom_layout --debug Configuration To customize the layout, edit the default config from graphsrv as needed. For additional documentation on layout config attributes, please refer to the graphsrv documentation on the subject. examples/custom_layout/layouts.yaml layouts: ## INDEX ##################################################################### index: type: index grid: 3x3 graph: config: multitarget fit: 'yes' targets: all ## DETAIL #################################################################### detail: type: custom layout: # row 1 (multi-target graph that will plot a line graph for all targets) - cols: # col 1, render a graph - graph: config: multitarget # fit to column fit: 'yes' # render all targets to this graph targets: all # custom graph id id: multitarget-1 # 100% width (12/12 columns) width: 12 # adjust the height of the multitarget graph to 50% (down from 75%) # to make room for the additional row of smokestack graphs height: 50 # row 2 (2 smokestack graphs side by side) - cols: - graph: fit: 'yes' config: smokestack targets: all id: smokestack-1 # 50% width (6/12 columns) width: 6 - graph: fit: 'yes' config: smokestack targets: all id: smokestack-2 # 50% width (6/12 columns) width: 6 # 25% height for the first row of smokestack graphs height: 25 # row 3 (2 smokestack graphs side by side) - cols: - graph: fit: 'yes' config: smokestack targets: all id: smokestack-1 # 50% width (6/12 columns) width: 6 - graph: fit: 'yes' config: smokestack targets: all id: smokestack-2 # 50% width (6/12 columns) width: 6 # 25% heigh for the second row of smokestack graphs height: 25 Then, specify a custom layout file should be loaded by setting the apps.graphsrv.layout_config_file config attribute in the vaping config. examples/custom_layout/config.yaml probes: - name: latency type: std_fping output: - vodka groups: - name: public_dns hosts: - host: 8.8.8.8 name: Google color: red - host: 4.2.2.1 name: Level(3) color: blue - host: 208.67.222.222 name: OpenDNS color: orange - host: 1.1.1.1 name: Cloudflare color: purple plugins: - name: std_fping type: fping count: 10 interval: 3s output: - vodka - name: vodka type: vodka data: - type: fping handlers: - type: index index: host - type: store container: list limit: 500 apps: graphsrv: enabled: true # point to custom layout config layout_config_file: examples/custom_layout/layouts.yaml graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg plugins: - name: http type: flask bind: 0.0.0.0:7021 debug: true static_url_path: /static server: self async: thread routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vodka: level: DEBUG handlers: - console #- file","title":"Customize Layout"},{"location":"layout/#customize-layout","text":"Vaping allows users to customize its layout by supplying a new layout config file. In the example below, the detail layout is changed to show 4 smokestack graphs instead of 3. Working directory matters for this example To test example below, please execute the command from the vaping root directory. The example provides a relative path to the layout file and will not find it otherwise. vaping start --home=examples/custom_layout --debug","title":"Customize Layout"},{"location":"layout/#configuration","text":"To customize the layout, edit the default config from graphsrv as needed. For additional documentation on layout config attributes, please refer to the graphsrv documentation on the subject. examples/custom_layout/layouts.yaml layouts: ## INDEX ##################################################################### index: type: index grid: 3x3 graph: config: multitarget fit: 'yes' targets: all ## DETAIL #################################################################### detail: type: custom layout: # row 1 (multi-target graph that will plot a line graph for all targets) - cols: # col 1, render a graph - graph: config: multitarget # fit to column fit: 'yes' # render all targets to this graph targets: all # custom graph id id: multitarget-1 # 100% width (12/12 columns) width: 12 # adjust the height of the multitarget graph to 50% (down from 75%) # to make room for the additional row of smokestack graphs height: 50 # row 2 (2 smokestack graphs side by side) - cols: - graph: fit: 'yes' config: smokestack targets: all id: smokestack-1 # 50% width (6/12 columns) width: 6 - graph: fit: 'yes' config: smokestack targets: all id: smokestack-2 # 50% width (6/12 columns) width: 6 # 25% height for the first row of smokestack graphs height: 25 # row 3 (2 smokestack graphs side by side) - cols: - graph: fit: 'yes' config: smokestack targets: all id: smokestack-1 # 50% width (6/12 columns) width: 6 - graph: fit: 'yes' config: smokestack targets: all id: smokestack-2 # 50% width (6/12 columns) width: 6 # 25% heigh for the second row of smokestack graphs height: 25 Then, specify a custom layout file should be loaded by setting the apps.graphsrv.layout_config_file config attribute in the vaping config. examples/custom_layout/config.yaml probes: - name: latency type: std_fping output: - vodka groups: - name: public_dns hosts: - host: 8.8.8.8 name: Google color: red - host: 4.2.2.1 name: Level(3) color: blue - host: 208.67.222.222 name: OpenDNS color: orange - host: 1.1.1.1 name: Cloudflare color: purple plugins: - name: std_fping type: fping count: 10 interval: 3s output: - vodka - name: vodka type: vodka data: - type: fping handlers: - type: index index: host - type: store container: list limit: 500 apps: graphsrv: enabled: true # point to custom layout config layout_config_file: examples/custom_layout/layouts.yaml graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg plugins: - name: http type: flask bind: 0.0.0.0:7021 debug: true static_url_path: /static server: self async: thread routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vodka: level: DEBUG handlers: - console #- file","title":"Configuration"},{"location":"quickstart/","text":"Install vaping You always need to install vaping with: pip install vaping Error due to outdated setuptools You may get an error when trying to install: error in vaping setup command: 'install_requires' must be a string or list of strings containing valid project/version requirement specifiers; Expected ',' or end-of-list in whichcraft==0.4.0 ; python_version<'3.3' at ; python_version<'3.3' This means you need to update your setuptools, you can do so by running pip install setuptools -U Install fping Most examples require fping to be installed. To install for CentOS or RHEL, you can get the package from EPEL: yum install epel-release yum install fping To install for Debian Or Ubuntu: sudo apt-get install fping Example Standalone Latency The example config file (from examples/standalone_dns ) uses both vodka and graphsrv plugins, so those will need to be installed with: pip install -U vodka pip install -U graphsrv You can still use old graphsrv We have recently added a major upgrade to graphsrv by switching to a d3.js based frontend. While this upgrade should be seamless on your end, if you still want to use the old graphsrv for now you can do so by pinning the version to 1.2.0 pip install graphsrv==1.2.0 Clone the github repository to have access to the example configuration files: git clone git@github.com:20c/vaping.git cd vaping Then just start vaping with: vaping start --home=examples/standalone_dns/ --debug By default it uses a generic layout template and listens on http://0.0.0.0:7021 - going to that in a browser should produce the summary paging which looks like: And clicking on the title will navigate to a detail page which looks like: Below is the config file, common things to change include: hosts: probes.public_dns.hosts listening address: plugins.vodka.plugins.http.host and port fping frequency: plugins.std_fping.count and interval Config file: examples/standalone_dns/config.yml : probes: - name: latency type: std_fping output: - vodka groups: - name: public_dns hosts: - host: 8.8.8.8 name: Google color: red - host: 4.2.2.1 name: Level(3) color: blue - host: 208.67.222.222 name: OpenDNS color: orange plugins: - name: std_fping type: fping count: 10 interval: 3s output: - vodka - name: vodka type: vodka data: - type: fping handlers: - type: index index: host - type: store container: list limit: 500 apps: graphsrv: enabled: true graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg plugins: - name: http type: flask bind: 0.0.0.0:7021 debug: true static_url_path: /static server: self async: thread routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vodka: level: DEBUG handlers: - console #- file Example Distributed Latency The example config file (from examples/distributed_dns ) is the same as the standalone one and uses both vodka and graphsrv, so those need to be installed with: pip install -U vodka pip install -U graphsrv Also if you are using zmq to send data between the processes (the default) you will need to install the pyzmq and zmq: pip install \"pyzmq<20\" In some instances you may also be required to install the zmq module alongside it. If you are getting startup issues try adding the following as well: pip install zmq The main difference is the collector is running in a separate process than the web server, which allows you to graph things from multiple locations, as well as using another webserver, such as nginx to serve client requests. To try it out, start vaping with: vaping start --home=examples/distributed_dns/vaping/ --debug Standalone vs Distributed Configs The example config files between standalone and distribtuted setups are not compatible. Running a distributed setup requires running vaping instance(s) and the web server like Gunicorn or UWSGI to present the web elements. Gunicorn To test with gunicorn, first install it: pip install gunicorn plugins['http'].server is already set to 'gunicorn' in examples/distributed_dns/vodka/config.yml so run: export VODKA_HOME=examples/distributed_dns/vodka gunicorn -b 0.0.0.0:7021 vodka.runners.wsgi:application You should be able to browse to port 7021 to see the display. Gunicorn fails to start If gunicorn fails to start and doesn't tell you why, it's probably some missing dependency. You can force it to output what it is failing on by passing the --preload argument to the gunicorn command. nginx To test with nginx, install uwsgi: pip install uwsgi In examples/distributed_dns/vodka/config.yml change plugins['http'].server to 'uwsgi' and then configure nginx with an upstream to connect to it. nginx.conf : upstream vaping { server 127.0.0.1:7021; } server { location / { uwsgi_pass vaping; include uwsgi_params; } } Start the uwsgi process with: export VODKA_HOME=examples/distributed_dns/vodka uwsgi -H $VIRTUAL_ENV --socket=0.0.0.0:7026 -w vodka.runners.wsgi:application --enable-threads You should be able to point your browser to the address nginx is listening on to view it. Note If you're running selinux, you'll need to allow nginx to connect to it with setsebool -P httpd_can_network_connect 1 . Config files: examples/distributed_dns/vaping/config.yml : probes: - name: latency type: std_fping output: - zmq_vodka groups: - name: public_dns hosts: - host: 8.8.8.8 name: Google color: red - host: 4.2.2.1 name: Level(3) color: blue - host: 208.67.222.222 name: OpenDNS color: orange plugins: - name: std_fping type: fping count: 10 interval: 3s - name: zmq_vodka type: zeromq bind: tcp://127.0.0.1:6021 logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file examples/distributed_dns/vodka/config.yml : data: - type: fping handlers: - type: index index: host - type: store container: list limit: 500 apps: graphsrv: enabled: true # here is where we define host config groups: latency: public_dns: 8.8.8.8: name: Google DNS color: red 4.2.2.1: name: Level(3) color: blue 208.67.222.222: name: OpenDNS color: orange graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg plugins: # zero mq probe plugin (latency name is important, so it can be # routed properly to the similarly named group) - name: latency type: zeromq_probe data: fping interval: 1.0 bind: tcp://127.0.0.1:6021 async: thread - name: http type: flask bind: 0.0.0.0:7021 debug: true # set this to gunicorn or uwsgi depending on what you want to run with server: gunicorn async: gevent routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout loggers: vodka: level: DEBUG handlers: - console Deep dive into the distributed example Looking at https://github.com/20c/vaping/tree/master/examples/distributed_dns There are two directories in there, one called vodka and one called vaping vodka is the config that is used by the vodka web service (so this would be your web server) vaping is the config that is used by a vaping process that runs and fping and send the data to vodka While the standalone variation of vaping can run vodka as a plugin, in this case both are meant to be run in separate processes and can be on separate hosts. Using the example: to start the web server on one host (using gunicorn to run it): export VODKA_HOME=examples/distributed_dns/vodka gunicorn -b 0.0.0.0:7021 vodka.runners.wsgi:application Then start the vaping that runs fping on a different host: vaping start --home=examples/distributed_dns/vaping/ --debug Configuring zmq and groups Vodka (web server) In the vodka config, each zeromq connection is instantiated by the zeromq_probe plugin, so it needs one of those for each vaping sending data. Please be aware of https://github.com/20c/vodka/issues/11 because it's a bit counterintuitive. plugins: ... # zero mq probe plugin (latency name is important, so it can be # routed properly to the similarly named group) - name: latency type: zeromq_probe data: fping interval: 1.0 bind: tcp://127.0.0.1:6021 async: thread Additionally, vodka will need to be made aware of any data group that will be sent to it, so each new vaping process will need a new group added in apps.graphsrv.groups apps: graphsrv: groups: # same name as zeromq_probe instance name above (important!) latency: public_dns: 8.8.8.8: name: Google DNS color: red 4.2.2.1: name: Level(3) color: blue 208.67.222.222: name: OpenDNS color: orange Vaping Likewise, in the vaping config you will need to configure the zmq connection via the zeromq plugin: plugins: ... - name: zmq_vodka type: zeromq bind: tcp://127.0.0.1:6021","title":"Quick Start Examples"},{"location":"quickstart/#install-vaping","text":"You always need to install vaping with: pip install vaping Error due to outdated setuptools You may get an error when trying to install: error in vaping setup command: 'install_requires' must be a string or list of strings containing valid project/version requirement specifiers; Expected ',' or end-of-list in whichcraft==0.4.0 ; python_version<'3.3' at ; python_version<'3.3' This means you need to update your setuptools, you can do so by running pip install setuptools -U","title":"Install vaping"},{"location":"quickstart/#install-fping","text":"Most examples require fping to be installed. To install for CentOS or RHEL, you can get the package from EPEL: yum install epel-release yum install fping To install for Debian Or Ubuntu: sudo apt-get install fping","title":"Install fping"},{"location":"quickstart/#example-standalone-latency","text":"The example config file (from examples/standalone_dns ) uses both vodka and graphsrv plugins, so those will need to be installed with: pip install -U vodka pip install -U graphsrv You can still use old graphsrv We have recently added a major upgrade to graphsrv by switching to a d3.js based frontend. While this upgrade should be seamless on your end, if you still want to use the old graphsrv for now you can do so by pinning the version to 1.2.0 pip install graphsrv==1.2.0 Clone the github repository to have access to the example configuration files: git clone git@github.com:20c/vaping.git cd vaping Then just start vaping with: vaping start --home=examples/standalone_dns/ --debug By default it uses a generic layout template and listens on http://0.0.0.0:7021 - going to that in a browser should produce the summary paging which looks like: And clicking on the title will navigate to a detail page which looks like: Below is the config file, common things to change include: hosts: probes.public_dns.hosts listening address: plugins.vodka.plugins.http.host and port fping frequency: plugins.std_fping.count and interval Config file: examples/standalone_dns/config.yml : probes: - name: latency type: std_fping output: - vodka groups: - name: public_dns hosts: - host: 8.8.8.8 name: Google color: red - host: 4.2.2.1 name: Level(3) color: blue - host: 208.67.222.222 name: OpenDNS color: orange plugins: - name: std_fping type: fping count: 10 interval: 3s output: - vodka - name: vodka type: vodka data: - type: fping handlers: - type: index index: host - type: store container: list limit: 500 apps: graphsrv: enabled: true graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg plugins: - name: http type: flask bind: 0.0.0.0:7021 debug: true static_url_path: /static server: self async: thread routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file vodka: level: DEBUG handlers: - console #- file","title":"Example Standalone Latency"},{"location":"quickstart/#example-distributed-latency","text":"The example config file (from examples/distributed_dns ) is the same as the standalone one and uses both vodka and graphsrv, so those need to be installed with: pip install -U vodka pip install -U graphsrv Also if you are using zmq to send data between the processes (the default) you will need to install the pyzmq and zmq: pip install \"pyzmq<20\" In some instances you may also be required to install the zmq module alongside it. If you are getting startup issues try adding the following as well: pip install zmq The main difference is the collector is running in a separate process than the web server, which allows you to graph things from multiple locations, as well as using another webserver, such as nginx to serve client requests. To try it out, start vaping with: vaping start --home=examples/distributed_dns/vaping/ --debug Standalone vs Distributed Configs The example config files between standalone and distribtuted setups are not compatible. Running a distributed setup requires running vaping instance(s) and the web server like Gunicorn or UWSGI to present the web elements.","title":"Example Distributed Latency"},{"location":"quickstart/#gunicorn","text":"To test with gunicorn, first install it: pip install gunicorn plugins['http'].server is already set to 'gunicorn' in examples/distributed_dns/vodka/config.yml so run: export VODKA_HOME=examples/distributed_dns/vodka gunicorn -b 0.0.0.0:7021 vodka.runners.wsgi:application You should be able to browse to port 7021 to see the display.","title":"Gunicorn"},{"location":"quickstart/#gunicorn-fails-to-start","text":"If gunicorn fails to start and doesn't tell you why, it's probably some missing dependency. You can force it to output what it is failing on by passing the --preload argument to the gunicorn command.","title":"Gunicorn fails to start"},{"location":"quickstart/#nginx","text":"To test with nginx, install uwsgi: pip install uwsgi In examples/distributed_dns/vodka/config.yml change plugins['http'].server to 'uwsgi' and then configure nginx with an upstream to connect to it. nginx.conf : upstream vaping { server 127.0.0.1:7021; } server { location / { uwsgi_pass vaping; include uwsgi_params; } } Start the uwsgi process with: export VODKA_HOME=examples/distributed_dns/vodka uwsgi -H $VIRTUAL_ENV --socket=0.0.0.0:7026 -w vodka.runners.wsgi:application --enable-threads You should be able to point your browser to the address nginx is listening on to view it. Note If you're running selinux, you'll need to allow nginx to connect to it with setsebool -P httpd_can_network_connect 1 . Config files: examples/distributed_dns/vaping/config.yml : probes: - name: latency type: std_fping output: - zmq_vodka groups: - name: public_dns hosts: - host: 8.8.8.8 name: Google color: red - host: 4.2.2.1 name: Level(3) color: blue - host: 208.67.222.222 name: OpenDNS color: orange plugins: - name: std_fping type: fping count: 10 interval: 3s - name: zmq_vodka type: zeromq bind: tcp://127.0.0.1:6021 logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout #file: # class: logging.FileHandler # level: DEBUG # formatter: simple # filename: /home/dev/sandbox/vaping/vaping.log loggers: vaping: level: DEBUG handlers: - console #- file examples/distributed_dns/vodka/config.yml : data: - type: fping handlers: - type: index index: host - type: store container: list limit: 500 apps: graphsrv: enabled: true # here is where we define host config groups: latency: public_dns: 8.8.8.8: name: Google DNS color: red 4.2.2.1: name: Level(3) color: blue 208.67.222.222: name: OpenDNS color: orange graphs: multitarget: id_field: host type: multitarget plot_y: avg format_y: ms smokestack: id_field: host type: smokestack plot_y: avg plugins: # zero mq probe plugin (latency name is important, so it can be # routed properly to the similarly named group) - name: latency type: zeromq_probe data: fping interval: 1.0 bind: tcp://127.0.0.1:6021 async: thread - name: http type: flask bind: 0.0.0.0:7021 debug: true # set this to gunicorn or uwsgi depending on what you want to run with server: gunicorn async: gevent routes: /targets : graphsrv->targets /graph_data : methods: - POST - GET target: graphsrv->graph_data /graph : graphsrv->graph_view /overview_read_file : graphsrv->overview_read_file /: graphsrv->overview_view logging: version: 1 formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s: %(message)s' handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout loggers: vodka: level: DEBUG handlers: - console","title":"nginx"},{"location":"quickstart/#deep-dive-into-the-distributed-example","text":"Looking at https://github.com/20c/vaping/tree/master/examples/distributed_dns There are two directories in there, one called vodka and one called vaping vodka is the config that is used by the vodka web service (so this would be your web server) vaping is the config that is used by a vaping process that runs and fping and send the data to vodka While the standalone variation of vaping can run vodka as a plugin, in this case both are meant to be run in separate processes and can be on separate hosts. Using the example: to start the web server on one host (using gunicorn to run it): export VODKA_HOME=examples/distributed_dns/vodka gunicorn -b 0.0.0.0:7021 vodka.runners.wsgi:application Then start the vaping that runs fping on a different host: vaping start --home=examples/distributed_dns/vaping/ --debug","title":"Deep dive into the distributed example"},{"location":"quickstart/#configuring-zmq-and-groups","text":"","title":"Configuring zmq and groups"},{"location":"quickstart/#vodka-web-server","text":"In the vodka config, each zeromq connection is instantiated by the zeromq_probe plugin, so it needs one of those for each vaping sending data. Please be aware of https://github.com/20c/vodka/issues/11 because it's a bit counterintuitive. plugins: ... # zero mq probe plugin (latency name is important, so it can be # routed properly to the similarly named group) - name: latency type: zeromq_probe data: fping interval: 1.0 bind: tcp://127.0.0.1:6021 async: thread Additionally, vodka will need to be made aware of any data group that will be sent to it, so each new vaping process will need a new group added in apps.graphsrv.groups apps: graphsrv: groups: # same name as zeromq_probe instance name above (important!) latency: public_dns: 8.8.8.8: name: Google DNS color: red 4.2.2.1: name: Level(3) color: blue 208.67.222.222: name: OpenDNS color: orange","title":"Vodka (web server)"},{"location":"quickstart/#vaping","text":"Likewise, in the vaping config you will need to configure the zmq connection via the zeromq plugin: plugins: ... - name: zmq_vodka type: zeromq bind: tcp://127.0.0.1:6021","title":"Vaping"},{"location":"api/vaping.cli/","text":"vaping.cli Functions mk_daemon def mk_daemon(ctx) Return a daemon.Vaping instance Arguments ctx ( Context ): vaping click context instance Returns vaping.daemon.Vaping instance Classes Context Context(munge.click.Context) Extended click context to use for vaping cli","title":"vaping.cli"},{"location":"api/vaping.cli/#vapingcli","text":"","title":"vaping.cli"},{"location":"api/vaping.cli/#functions","text":"","title":"Functions"},{"location":"api/vaping.cli/#mk_daemon","text":"def mk_daemon(ctx) Return a daemon.Vaping instance Arguments ctx ( Context ): vaping click context instance Returns vaping.daemon.Vaping instance","title":"mk_daemon"},{"location":"api/vaping.cli/#classes","text":"","title":"Classes"},{"location":"api/vaping.cli/#context","text":"Context(munge.click.Context) Extended click context to use for vaping cli","title":"Context"},{"location":"api/vaping.config/","text":"vaping.config Functions parse_interval def parse_interval(val) converts a string to float of seconds .5 = 500ms 90 = 1m30s Arguments val ( str ) Classes Config Config(munge.config.Config) Vaping config manager","title":"vaping.config"},{"location":"api/vaping.config/#vapingconfig","text":"","title":"vaping.config"},{"location":"api/vaping.config/#functions","text":"","title":"Functions"},{"location":"api/vaping.config/#parse_interval","text":"def parse_interval(val) converts a string to float of seconds .5 = 500ms 90 = 1m30s Arguments val ( str )","title":"parse_interval"},{"location":"api/vaping.config/#classes","text":"","title":"Classes"},{"location":"api/vaping.config/#config","text":"Config(munge.config.Config) Vaping config manager","title":"Config"},{"location":"api/vaping.daemon/","text":"vaping.daemon Classes PluginContext PluginContext(builtins.object) Context to pass to plugins for getting extra information Instanced Attributes These attributes / properties will be available on instances of the class config ( @property ): config Methods __init__ def __init__(self, config) Initialize self. See help(type(self)) for accurate signature. Vaping Vaping(builtins.object) Vaping daemon class Instanced Attributes These attributes / properties will be available on instances of the class get_logging_handles ( @property ): None log ( @property ): logger instance pidfile ( @property ): None Methods __init__ def __init__(self, config=None, config_dir=None) must either pass config as a dict or vaping.config.Config or config_dir as a path to where the config dir is located _exec def _exec(self, detach=True) daemonize and exec main() _main def _main(self) process run def run(self) run daemon start def start(self) start daemon stop def stop(self) stop daemon","title":"vaping.daemon"},{"location":"api/vaping.daemon/#vapingdaemon","text":"","title":"vaping.daemon"},{"location":"api/vaping.daemon/#classes","text":"","title":"Classes"},{"location":"api/vaping.daemon/#plugincontext","text":"PluginContext(builtins.object) Context to pass to plugins for getting extra information","title":"PluginContext"},{"location":"api/vaping.daemon/#instanced-attributes","text":"These attributes / properties will be available on instances of the class config ( @property ): config","title":"Instanced Attributes"},{"location":"api/vaping.daemon/#methods","text":"","title":"Methods"},{"location":"api/vaping.daemon/#__init__","text":"def __init__(self, config) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"api/vaping.daemon/#vaping","text":"Vaping(builtins.object) Vaping daemon class","title":"Vaping"},{"location":"api/vaping.daemon/#instanced-attributes_1","text":"These attributes / properties will be available on instances of the class get_logging_handles ( @property ): None log ( @property ): logger instance pidfile ( @property ): None","title":"Instanced Attributes"},{"location":"api/vaping.daemon/#methods_1","text":"","title":"Methods"},{"location":"api/vaping.daemon/#__init___1","text":"def __init__(self, config=None, config_dir=None) must either pass config as a dict or vaping.config.Config or config_dir as a path to where the config dir is located","title":"__init__"},{"location":"api/vaping.daemon/#_exec","text":"def _exec(self, detach=True) daemonize and exec main()","title":"_exec"},{"location":"api/vaping.daemon/#_main","text":"def _main(self) process","title":"_main"},{"location":"api/vaping.daemon/#run","text":"def run(self) run daemon","title":"run"},{"location":"api/vaping.daemon/#start","text":"def start(self) start daemon","title":"start"},{"location":"api/vaping.daemon/#stop","text":"def stop(self) stop daemon","title":"stop"},{"location":"api/vaping.io/","text":"vaping.io vaping io functionality Classes Queue Queue(asyncio.queues.Queue) A queue, useful for coordinating producer and consumer coroutines. If maxsize is less than or equal to zero, the queue size is infinite. If it is an integer greater than 0, then \"await put()\" will block when the queue reaches maxsize, until an item is removed by get(). Unlike the standard library Queue, you can reliably know this Queue's size with qsize(), since your single-threaded asyncio application won't be interrupted between calling qsize() and doing an operation on the Queue.","title":"vaping.io"},{"location":"api/vaping.io/#vapingio","text":"vaping io functionality","title":"vaping.io"},{"location":"api/vaping.io/#classes","text":"","title":"Classes"},{"location":"api/vaping.io/#queue","text":"Queue(asyncio.queues.Queue) A queue, useful for coordinating producer and consumer coroutines. If maxsize is less than or equal to zero, the queue size is infinite. If it is an integer greater than 0, then \"await put()\" will block when the queue reaches maxsize, until an item is removed by get(). Unlike the standard library Queue, you can reliably know this Queue's size with qsize(), since your single-threaded asyncio application won't be interrupted between calling qsize() and doing an operation on the Queue.","title":"Queue"},{"location":"api/vaping/","text":"vaping Classes PluginManager PluginManager(pluginmgr.config.ConfigPluginManager) Vaping plugin manager An instance of this will be instantiated automatically and be available as vaping.plugin Methods exists def exists(self, name) Check if plugin instance exists Arguments name ( str ): plugin instance name Returns True if instance exists, False if not","title":"vaping"},{"location":"api/vaping/#vaping","text":"","title":"vaping"},{"location":"api/vaping/#classes","text":"","title":"Classes"},{"location":"api/vaping/#pluginmanager","text":"PluginManager(pluginmgr.config.ConfigPluginManager) Vaping plugin manager An instance of this will be instantiated automatically and be available as vaping.plugin","title":"PluginManager"},{"location":"api/vaping/#methods","text":"","title":"Methods"},{"location":"api/vaping/#exists","text":"def exists(self, name) Check if plugin instance exists Arguments name ( str ): plugin instance name Returns True if instance exists, False if not","title":"exists"},{"location":"api/vaping.plugins.command/","text":"vaping.plugins.command Classes CommandProbe CommandProbe(vaping.plugins.TimedProbe) Probe type plugin that allows you to run an arbitrary command for each host and return the command output as data Config command ( str ): command to run (use {host} to reference the host) interval ( float ): time between probes Instanced Attributes These attributes / properties will be available on instances of the class command ( str ): command to run Methods init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code probe def probe(self) probe for data, return a list of dicts","title":"vaping.plugins.command"},{"location":"api/vaping.plugins.command/#vapingpluginscommand","text":"","title":"vaping.plugins.command"},{"location":"api/vaping.plugins.command/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins.command/#commandprobe","text":"CommandProbe(vaping.plugins.TimedProbe) Probe type plugin that allows you to run an arbitrary command for each host and return the command output as data","title":"CommandProbe"},{"location":"api/vaping.plugins.command/#config","text":"command ( str ): command to run (use {host} to reference the host) interval ( float ): time between probes","title":"Config"},{"location":"api/vaping.plugins.command/#instanced-attributes","text":"These attributes / properties will be available on instances of the class command ( str ): command to run","title":"Instanced Attributes"},{"location":"api/vaping.plugins.command/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins.command/#init","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins.command/#probe","text":"def probe(self) probe for data, return a list of dicts","title":"probe"},{"location":"api/vaping.plugins.fping/","text":"vaping.plugins.fping Classes FPing FPing(vaping.plugins.fping.FPingBase) Run fping on configured hosts Config command ( str=fping ): command to run interval ( str=1m ): time between pings count ( int=5 ): number of pings to send period ( int=20 ): time in milliseconds that fping waits between successive packets to an individual target Methods init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code probe def probe(self) probe for data, return a list of dicts FPingBase FPingBase(vaping.plugins.TimedProbe) FPing base plugin config: Config command ( str=fping ): command to run interval ( str=1m ): time between pings count ( int=5 ): number of pings to send period ( int=20 ): time in milliseconds that fping waits between successive packets to an individual target Class Attributes ConfigSchema ( FPingSchema Class ): Base plugin config schema Instanced Attributes These attributes / properties will be available on instances of the class count ( int ): number of fpings to send period ( int ): time in milliseconds that fping waits between successive packets Methods __init__ def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context hosts_args def hosts_args(self) hosts list can contain strings specifying a host directly or dicts containing a \"host\" key to specify the host this way we can allow passing further config details (color, name etc.) with each host as well as simply dropping in addresses for quick setup depending on the user's needs parse_verbose def parse_verbose(self, line) parse output from verbose format Returns parsed fping result ( dict ) host : host name cnt : fpings sent loss data : list of inidivual fping times min : smallest fping time max : biggest fping time avg : average fping time last : last fping time FPingSchema FPingSchema(vaping.plugins.TimedProbeSchema) Define a schema for FPing and also define defaults. Class Attributes command ( Str Instance ): Command to run count ( Int Instance ): Number of pings to send interval ( Str Instance ): Time between pings output ( List Instance ): Determine what plugin displays output period ( Int Instance ): Time in milliseconds that fping waits between successive packets to an individual target","title":"vaping.plugins.fping"},{"location":"api/vaping.plugins.fping/#vapingpluginsfping","text":"","title":"vaping.plugins.fping"},{"location":"api/vaping.plugins.fping/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins.fping/#fping","text":"FPing(vaping.plugins.fping.FPingBase) Run fping on configured hosts","title":"FPing"},{"location":"api/vaping.plugins.fping/#config","text":"command ( str=fping ): command to run interval ( str=1m ): time between pings count ( int=5 ): number of pings to send period ( int=20 ): time in milliseconds that fping waits between successive packets to an individual target","title":"Config"},{"location":"api/vaping.plugins.fping/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins.fping/#init","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins.fping/#probe","text":"def probe(self) probe for data, return a list of dicts","title":"probe"},{"location":"api/vaping.plugins.fping/#fpingbase","text":"FPingBase(vaping.plugins.TimedProbe) FPing base plugin config:","title":"FPingBase"},{"location":"api/vaping.plugins.fping/#config_1","text":"command ( str=fping ): command to run interval ( str=1m ): time between pings count ( int=5 ): number of pings to send period ( int=20 ): time in milliseconds that fping waits between successive packets to an individual target","title":"Config"},{"location":"api/vaping.plugins.fping/#class-attributes","text":"ConfigSchema ( FPingSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins.fping/#instanced-attributes","text":"These attributes / properties will be available on instances of the class count ( int ): number of fpings to send period ( int ): time in milliseconds that fping waits between successive packets","title":"Instanced Attributes"},{"location":"api/vaping.plugins.fping/#methods_1","text":"","title":"Methods"},{"location":"api/vaping.plugins.fping/#__init__","text":"def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins.fping/#hosts_args","text":"def hosts_args(self) hosts list can contain strings specifying a host directly or dicts containing a \"host\" key to specify the host this way we can allow passing further config details (color, name etc.) with each host as well as simply dropping in addresses for quick setup depending on the user's needs","title":"hosts_args"},{"location":"api/vaping.plugins.fping/#parse_verbose","text":"def parse_verbose(self, line) parse output from verbose format Returns parsed fping result ( dict ) host : host name cnt : fpings sent loss data : list of inidivual fping times min : smallest fping time max : biggest fping time avg : average fping time last : last fping time","title":"parse_verbose"},{"location":"api/vaping.plugins.fping/#fpingschema","text":"FPingSchema(vaping.plugins.TimedProbeSchema) Define a schema for FPing and also define defaults.","title":"FPingSchema"},{"location":"api/vaping.plugins.fping/#class-attributes_1","text":"command ( Str Instance ): Command to run count ( Int Instance ): Number of pings to send interval ( Str Instance ): Time between pings output ( List Instance ): Determine what plugin displays output period ( Int Instance ): Time in milliseconds that fping waits between successive packets to an individual target","title":"Class Attributes"},{"location":"api/vaping.plugins.fping_mtr/","text":"vaping.plugins.fping_mtr Classes FPingMTR FPingMTR(vaping.plugins.fping.FPingBase) Run fping on a traceroute path Config interval ( float ) time between pings count ( int ) number of pings to send Instanced Attributes These attributes / properties will be available on instances of the class hosts ( list ) lines_read ( int ) mtr_host ( str ) Methods get_hosts def get_hosts(self) Run traceroute for the mtr_host host and return the hosts found in the route Returns hosts ( list<str> ): list of hosts in the route to mtr_host init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code parse_traceroute def parse_traceroute(self, it) parse traceroute output Arguments it: collection of lines to iterate through Returns hosts ( list<str> ): list of hosts in the traceroute result parse_traceroute_line def parse_traceroute_line(self, line) parse host from verbose traceroute result format Arguments line (string type): line from traceroutei result output Returns host ( str ) probe def probe(self) Gets a list of hosts via get_hosts and then runs fping against all of them to build mtr data Returns msg ( dict )","title":"vaping.plugins.fping_mtr"},{"location":"api/vaping.plugins.fping_mtr/#vapingpluginsfping_mtr","text":"","title":"vaping.plugins.fping_mtr"},{"location":"api/vaping.plugins.fping_mtr/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins.fping_mtr/#fpingmtr","text":"FPingMTR(vaping.plugins.fping.FPingBase) Run fping on a traceroute path","title":"FPingMTR"},{"location":"api/vaping.plugins.fping_mtr/#config","text":"interval ( float ) time between pings count ( int ) number of pings to send","title":"Config"},{"location":"api/vaping.plugins.fping_mtr/#instanced-attributes","text":"These attributes / properties will be available on instances of the class hosts ( list ) lines_read ( int ) mtr_host ( str )","title":"Instanced Attributes"},{"location":"api/vaping.plugins.fping_mtr/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins.fping_mtr/#get_hosts","text":"def get_hosts(self) Run traceroute for the mtr_host host and return the hosts found in the route Returns hosts ( list<str> ): list of hosts in the route to mtr_host","title":"get_hosts"},{"location":"api/vaping.plugins.fping_mtr/#init","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins.fping_mtr/#parse_traceroute","text":"def parse_traceroute(self, it) parse traceroute output Arguments it: collection of lines to iterate through Returns hosts ( list<str> ): list of hosts in the traceroute result","title":"parse_traceroute"},{"location":"api/vaping.plugins.fping_mtr/#parse_traceroute_line","text":"def parse_traceroute_line(self, line) parse host from verbose traceroute result format Arguments line (string type): line from traceroutei result output Returns host ( str )","title":"parse_traceroute_line"},{"location":"api/vaping.plugins.fping_mtr/#probe","text":"def probe(self) Gets a list of hosts via get_hosts and then runs fping against all of them to build mtr data Returns msg ( dict )","title":"probe"},{"location":"api/vaping.plugins.logparse/","text":"vaping.plugins.logparse Classes AggregateSchema AggregateSchema(confu.schema.core.Schema) Describes a confu schema. Instantiate confu attributes as properties of the schema. As the schema itself is a confu attribute, you may nest schemas within schemas Example class MySchema(Schema): str_attr = Str() Class Attributes count ( Int Instance ): Aggregate n lines FieldSchema FieldSchema(confu.schema.core.Schema) Describes a confu schema. Instantiate confu attributes as properties of the schema. As the schema itself is a confu attribute, you may nest schemas within schemas Example class MySchema(Schema): str_attr = Str() Class Attributes aggregate ( Str Instance ): How to aggregate the field if aggregation is turned on (sum, avg, eval) eval ( Str Instance ): Evaluate to create the value, other fields' values will be available in the string formatting parser ( Str Instance ): Regex pattern to parse field value, needs to one group in it type ( Str Instance ): Value type (int, float etc.) LogParse LogParse(vaping.plugins.FileProbe) Log parse plugin base Will parse a log line by line and probe to emit data over a specified interval. Config path ( str ): log file path fields ( dict ): field definition field name as key parser regex pattern to parse field value, needs to one group in it type value type (int, float etc.) aggregate how to aggregate the field if aggregation is turned on (sum, avg, eval) eval evaluate to create the value, other fields values will be available in the string formatting time_parser ( dict ) if specified will be passed to strptime to generate a timestamp from the logline time_parser: find: \\d\\d:\\d\\d:\\d\\d format: %H:%M:%S exclude ( list ): list of regex patterns that will cause lines to be excluded on match include ( list ): list of regex patterns that will cause lines to be included on match aggregate ( dict ): aggregation config - count aggregate n lines Instance Attributes stack ( list ) fields ( dict ): field config aggregate_count ( int ) exclude ( list ) include ( list ) time_parser ( dict ) Class Attributes ConfigSchema ( LogParseSchema Class ): Base plugin config schema Methods aggregate def aggregate(self, messages) Takes a list of messages and aggregates them according to aggration config Arguments messagges ( list<dict> ) Returns list of aggregated messages ( list<dict> ) aggregate_avg def aggregate_avg(self, field_name, rows) Aggregate average value Arguments field_name ( str ): field to aggregate rows ( list ): list of vaping message data rows Returns avg ( float ) aggregate_eval def aggregate_eval(self, field_name, rows) Aggregate using an eval() result Needs to have eval set in the field config. Value will be passed straight to the eval() function so caution is advised. Arguments field_name ( str ): field to aggregate rows ( list ): list of vaping message data rows Returns eval result aggregate_field def aggregate_field(self, field_name, rows) takes a field name and a set of rows and will return an aggregated value this requires for the field to have it's aggregate config specified in the probe config Arguments field_name ( str ) rows ( list ) Returns aggregated value aggregate_message def aggregate_message(self, message) Takesa vaping message with multiple items in it's data property and aggregates that data Arguments message ( dict ): vaping message dict aggregate_sum def aggregate_sum(self, field_name, rows) Aggregate sum Arguments field_name ( str ): field to aggregate rows ( list ): list of vaping message data rows Returns sum init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code parse_field_value def parse_field_value(self, field, line) takes a field definition and a log line and attempts to parse out the field's value parse_line def parse_line(self, line) Here is where we parse values out of a single line read from the log and return a dict containg keys and values Arguments line ( str ) process_line def process_line(self, line, data) The data dict represents the current emit object, depending on your interval multiple lines may be included in the same emit object. Should return the data object Arguments line ( str ): log line data ( dict ): current emit dict process_messages def process_messages(self, messages) Process vaping messages before the are emitted Aggregation is handled here Arguments messages ( list ): list of vaping messages Returns Result of self.aggregate validate_interval def validate_interval(self, value) validates a string describing elapsed time or time duration Arguments value ( str ): elapsed time (example: 1d2h) Returns seconds ( float ) LogParseSchema LogParseSchema(vaping.plugins.PluginConfigSchema) Define a schema for FPing and also define defaults. Class Attributes aggregate ( AggregateSchema Instance ): aggregation config exclude ( List Instance ): list of regex patterns that will cause lines to be excluded on match fields ( Dict Instance ): Field definition include ( List Instance ): list of regex patterns that will cause lines to be included on match time_parser ( TimeParserSchema Instance ): If specified will be passed to strptime to generate a timestamp from the logline TimeParserSchema TimeParserSchema(confu.schema.core.Schema) Describes a confu schema. Instantiate confu attributes as properties of the schema. As the schema itself is a confu attribute, you may nest schemas within schemas Example class MySchema(Schema): str_attr = Str() Class Attributes find ( Str Instance ): Regex string to find timestamps. format ( Str Instance ): Datetime format to output timestamps.","title":"vaping.plugins.logparse"},{"location":"api/vaping.plugins.logparse/#vapingpluginslogparse","text":"","title":"vaping.plugins.logparse"},{"location":"api/vaping.plugins.logparse/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins.logparse/#aggregateschema","text":"AggregateSchema(confu.schema.core.Schema) Describes a confu schema. Instantiate confu attributes as properties of the schema. As the schema itself is a confu attribute, you may nest schemas within schemas Example class MySchema(Schema): str_attr = Str()","title":"AggregateSchema"},{"location":"api/vaping.plugins.logparse/#class-attributes","text":"count ( Int Instance ): Aggregate n lines","title":"Class Attributes"},{"location":"api/vaping.plugins.logparse/#fieldschema","text":"FieldSchema(confu.schema.core.Schema) Describes a confu schema. Instantiate confu attributes as properties of the schema. As the schema itself is a confu attribute, you may nest schemas within schemas Example class MySchema(Schema): str_attr = Str()","title":"FieldSchema"},{"location":"api/vaping.plugins.logparse/#class-attributes_1","text":"aggregate ( Str Instance ): How to aggregate the field if aggregation is turned on (sum, avg, eval) eval ( Str Instance ): Evaluate to create the value, other fields' values will be available in the string formatting parser ( Str Instance ): Regex pattern to parse field value, needs to one group in it type ( Str Instance ): Value type (int, float etc.)","title":"Class Attributes"},{"location":"api/vaping.plugins.logparse/#logparse","text":"LogParse(vaping.plugins.FileProbe) Log parse plugin base Will parse a log line by line and probe to emit data over a specified interval.","title":"LogParse"},{"location":"api/vaping.plugins.logparse/#config","text":"path ( str ): log file path fields ( dict ): field definition field name as key parser regex pattern to parse field value, needs to one group in it type value type (int, float etc.) aggregate how to aggregate the field if aggregation is turned on (sum, avg, eval) eval evaluate to create the value, other fields values will be available in the string formatting time_parser ( dict ) if specified will be passed to strptime to generate a timestamp from the logline time_parser: find: \\d\\d:\\d\\d:\\d\\d format: %H:%M:%S exclude ( list ): list of regex patterns that will cause lines to be excluded on match include ( list ): list of regex patterns that will cause lines to be included on match aggregate ( dict ): aggregation config - count aggregate n lines","title":"Config"},{"location":"api/vaping.plugins.logparse/#instance-attributes","text":"stack ( list ) fields ( dict ): field config aggregate_count ( int ) exclude ( list ) include ( list ) time_parser ( dict )","title":"Instance Attributes"},{"location":"api/vaping.plugins.logparse/#class-attributes_2","text":"ConfigSchema ( LogParseSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins.logparse/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins.logparse/#aggregate","text":"def aggregate(self, messages) Takes a list of messages and aggregates them according to aggration config Arguments messagges ( list<dict> ) Returns list of aggregated messages ( list<dict> )","title":"aggregate"},{"location":"api/vaping.plugins.logparse/#aggregate_avg","text":"def aggregate_avg(self, field_name, rows) Aggregate average value Arguments field_name ( str ): field to aggregate rows ( list ): list of vaping message data rows Returns avg ( float )","title":"aggregate_avg"},{"location":"api/vaping.plugins.logparse/#aggregate_eval","text":"def aggregate_eval(self, field_name, rows) Aggregate using an eval() result Needs to have eval set in the field config. Value will be passed straight to the eval() function so caution is advised. Arguments field_name ( str ): field to aggregate rows ( list ): list of vaping message data rows Returns eval result","title":"aggregate_eval"},{"location":"api/vaping.plugins.logparse/#aggregate_field","text":"def aggregate_field(self, field_name, rows) takes a field name and a set of rows and will return an aggregated value this requires for the field to have it's aggregate config specified in the probe config Arguments field_name ( str ) rows ( list ) Returns aggregated value","title":"aggregate_field"},{"location":"api/vaping.plugins.logparse/#aggregate_message","text":"def aggregate_message(self, message) Takesa vaping message with multiple items in it's data property and aggregates that data Arguments message ( dict ): vaping message dict","title":"aggregate_message"},{"location":"api/vaping.plugins.logparse/#aggregate_sum","text":"def aggregate_sum(self, field_name, rows) Aggregate sum Arguments field_name ( str ): field to aggregate rows ( list ): list of vaping message data rows Returns sum","title":"aggregate_sum"},{"location":"api/vaping.plugins.logparse/#init","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins.logparse/#parse_field_value","text":"def parse_field_value(self, field, line) takes a field definition and a log line and attempts to parse out the field's value","title":"parse_field_value"},{"location":"api/vaping.plugins.logparse/#parse_line","text":"def parse_line(self, line) Here is where we parse values out of a single line read from the log and return a dict containg keys and values Arguments line ( str )","title":"parse_line"},{"location":"api/vaping.plugins.logparse/#process_line","text":"def process_line(self, line, data) The data dict represents the current emit object, depending on your interval multiple lines may be included in the same emit object. Should return the data object Arguments line ( str ): log line data ( dict ): current emit dict","title":"process_line"},{"location":"api/vaping.plugins.logparse/#process_messages","text":"def process_messages(self, messages) Process vaping messages before the are emitted Aggregation is handled here Arguments messages ( list ): list of vaping messages Returns Result of self.aggregate","title":"process_messages"},{"location":"api/vaping.plugins.logparse/#validate_interval","text":"def validate_interval(self, value) validates a string describing elapsed time or time duration Arguments value ( str ): elapsed time (example: 1d2h) Returns seconds ( float )","title":"validate_interval"},{"location":"api/vaping.plugins.logparse/#logparseschema","text":"LogParseSchema(vaping.plugins.PluginConfigSchema) Define a schema for FPing and also define defaults.","title":"LogParseSchema"},{"location":"api/vaping.plugins.logparse/#class-attributes_3","text":"aggregate ( AggregateSchema Instance ): aggregation config exclude ( List Instance ): list of regex patterns that will cause lines to be excluded on match fields ( Dict Instance ): Field definition include ( List Instance ): list of regex patterns that will cause lines to be included on match time_parser ( TimeParserSchema Instance ): If specified will be passed to strptime to generate a timestamp from the logline","title":"Class Attributes"},{"location":"api/vaping.plugins.logparse/#timeparserschema","text":"TimeParserSchema(confu.schema.core.Schema) Describes a confu schema. Instantiate confu attributes as properties of the schema. As the schema itself is a confu attribute, you may nest schemas within schemas Example class MySchema(Schema): str_attr = Str()","title":"TimeParserSchema"},{"location":"api/vaping.plugins.logparse/#class-attributes_4","text":"find ( Str Instance ): Regex string to find timestamps. format ( Str Instance ): Datetime format to output timestamps.","title":"Class Attributes"},{"location":"api/vaping.plugins/","text":"vaping.plugins Classes EmitBase EmitBase(vaping.plugins.PluginBase) Base class for emit plugins, used for sending data expects method emit() to be defined Methods __init__ def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context emit def emit(self, message) accept message to emit FileProbe FileProbe(vaping.plugins.ProbeBase) Probes a file and emits everytime a new line is read Config path ( str ): path to file backlog ( int=0 ): number of bytes to read from backlog max_lines ( int=1000 ): maximum number of lines to read during probe Class Attributes ConfigSchema ( FileProbeSchema Class ): Base plugin config schema Instanced Attributes These attributes / properties will be available on instances of the class backlog ( int ): number of bytes to read from backlog fh ( filehandler ): file handler for opened file (only available if path is set) max_lines ( int ): maximum number of liens to read during probe path ( str ): path to file Methods __init__ def __init__(self, config, ctx, emit=None) Arguments config ( dict ) ctx: vaping context probe def probe(self) Probe the file for new lines process_line def process_line(self, line, data) override this - parse your line in here process_messages def process_messages(self, messages) override this - process your messages before they are emitted process_probe def process_probe(self, data) override this - assign your data values here validate_file_handler def validate_file_handler(self) Here we validate that our filehandler is pointing to an existing file. If it doesnt, because file has been deleted, we close the filehander and try to reopen FileProbeSchema FileProbeSchema(vaping.plugins.PluginConfigSchema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this. Class Attributes backlog ( Int Instance ): max_lines ( Int Instance ): path ( Str Instance ): PluginBase PluginBase(vaping.io.Thread) Base plugin interface Class Attributes lazy_start ( bool = False ): if True plugin will not be started on vaping start, but when at a later point (usually when it starts emitting). Note that the plugin itself will need to call self.start() somewhere explicitly when this is True . Calls self.init() prefork while loading all modules, init() should not do anything active, any files opened may be closed when it forks. Plugins should prefer init() to __init__() to ensure the class is completely done initializing. Calls self.on_start() and self.on_stop() before and after running in case any connections need to be created or cleaned up. Class Attributes ConfigSchema ( PluginConfigSchema Class ): Base plugin config schema Instanced Attributes These attributes / properties will be available on instances of the class config ( dict ): plugin config groups ( @property ): dict - group configurations keyed by name log ( @property ): logger instance for plugin type vaping: reference to the main vaping object Methods __init__ def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code new_message def new_message(self) creates and returns new message dict , setting type , source , ts , data data is initialized to an empty array Returns message ( dict ) on_start def on_start(self) called when the daemon is starting on_stop def on_stop(self) called when the daemon is stopping popen def popen(self, args, **kwargs) creates a subprocess with passed args Returns Popen instance PluginConfigSchema PluginConfigSchema(confu.schema.core.Schema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this. Class Attributes name ( Str Instance ): Plugin name type ( Str Instance ): Plugin type ProbeBase ProbeBase(vaping.plugins.PluginBase) Base class for probe plugin, used for getting data expects method probe() to be defined Methods __init__ def __init__(self, config, ctx, emit=None) Arguments config ( dict ) ctx: vaping context emit_all def emit_all(self) emit and remove all emissions in the queue init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code probe def probe(self) probe for data, return a list of dicts queue_emission def queue_emission(self, msg) queue an emission of a message for all output plugins Arguments msg ( dict ): dict containing type , source , ts and data keys send_emission def send_emission(self) emit and remove the first emission in the queue TimeSeriesDB TimeSeriesDB(vaping.plugins.EmitBase) Base interface for timeseries db storage plugins Config filename ( str ): database file name template field ( str ): field name to read the value from Class Attributes ConfigSchema ( TimeSeriesDBSchema Class ): Base plugin config schema Instanced Attributes These attributes / properties will be available on instances of the class field ( str ): fieeld name to read the value from filename ( str ): database file name template Methods __init__ def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context create def create(self, filename) Create database Arguments filename ( str ): database filename emit def emit(self, message) emit to database Arguments message ( dict ): vaping message dict filename_formatters def filename_formatters(self, data, row) Returns a dict containing the various filename formatter values Values are gotten from the vaping data message as well as the currently processed row in the message Arguments data ( dict ): vaping message row ( dict ): vaping message data row Returns formatter variables ( dict ) format_filename def format_filename(self, data, row) Returns a formatted filename using the template stored in self.filename Arguments data ( dict ): vaping message row ( dict ): vaping message data row Returns formatted version of self.filename ( str ) get def get(self, filename, from_time, to_time) Retrieve data from database for the specified timespan Arguments filename ( str ): database filename from_time ( int ): epoch timestamp start to_time ( int ): epoch timestamp end update def update(self, filename, time, value) Update database Arguments filename ( str ): database filename time ( int ): epoch timestamp value ( mixed ) TimeSeriesDBSchema TimeSeriesDBSchema(vaping.plugins.PluginConfigSchema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this. Class Attributes field ( Str Instance ): field name to read the value from filename ( Str Instance ): database file name template TimedProbe TimedProbe(vaping.plugins.ProbeBase) Probe class that calls probe every config defined interval Class Attributes ConfigSchema ( TimedProbeSchema Class ): Base plugin config schema Methods __init__ def __init__(self, config, ctx, emit=None) Arguments config ( dict ) ctx: vaping context TimedProbeSchema TimedProbeSchema(vaping.plugins.PluginConfigSchema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this. Class Attributes interval ( Str Instance ):","title":"vaping.plugins"},{"location":"api/vaping.plugins/#vapingplugins","text":"","title":"vaping.plugins"},{"location":"api/vaping.plugins/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins/#emitbase","text":"EmitBase(vaping.plugins.PluginBase) Base class for emit plugins, used for sending data expects method emit() to be defined","title":"EmitBase"},{"location":"api/vaping.plugins/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins/#__init__","text":"def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins/#emit","text":"def emit(self, message) accept message to emit","title":"emit"},{"location":"api/vaping.plugins/#fileprobe","text":"FileProbe(vaping.plugins.ProbeBase) Probes a file and emits everytime a new line is read","title":"FileProbe"},{"location":"api/vaping.plugins/#config","text":"path ( str ): path to file backlog ( int=0 ): number of bytes to read from backlog max_lines ( int=1000 ): maximum number of lines to read during probe","title":"Config"},{"location":"api/vaping.plugins/#class-attributes","text":"ConfigSchema ( FileProbeSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins/#instanced-attributes","text":"These attributes / properties will be available on instances of the class backlog ( int ): number of bytes to read from backlog fh ( filehandler ): file handler for opened file (only available if path is set) max_lines ( int ): maximum number of liens to read during probe path ( str ): path to file","title":"Instanced Attributes"},{"location":"api/vaping.plugins/#methods_1","text":"","title":"Methods"},{"location":"api/vaping.plugins/#__init___1","text":"def __init__(self, config, ctx, emit=None) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins/#probe","text":"def probe(self) Probe the file for new lines","title":"probe"},{"location":"api/vaping.plugins/#process_line","text":"def process_line(self, line, data) override this - parse your line in here","title":"process_line"},{"location":"api/vaping.plugins/#process_messages","text":"def process_messages(self, messages) override this - process your messages before they are emitted","title":"process_messages"},{"location":"api/vaping.plugins/#process_probe","text":"def process_probe(self, data) override this - assign your data values here","title":"process_probe"},{"location":"api/vaping.plugins/#validate_file_handler","text":"def validate_file_handler(self) Here we validate that our filehandler is pointing to an existing file. If it doesnt, because file has been deleted, we close the filehander and try to reopen","title":"validate_file_handler"},{"location":"api/vaping.plugins/#fileprobeschema","text":"FileProbeSchema(vaping.plugins.PluginConfigSchema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this.","title":"FileProbeSchema"},{"location":"api/vaping.plugins/#class-attributes_1","text":"backlog ( Int Instance ): max_lines ( Int Instance ): path ( Str Instance ):","title":"Class Attributes"},{"location":"api/vaping.plugins/#pluginbase","text":"PluginBase(vaping.io.Thread) Base plugin interface","title":"PluginBase"},{"location":"api/vaping.plugins/#class-attributes_2","text":"lazy_start ( bool = False ): if True plugin will not be started on vaping start, but when at a later point (usually when it starts emitting). Note that the plugin itself will need to call self.start() somewhere explicitly when this is True . Calls self.init() prefork while loading all modules, init() should not do anything active, any files opened may be closed when it forks. Plugins should prefer init() to __init__() to ensure the class is completely done initializing. Calls self.on_start() and self.on_stop() before and after running in case any connections need to be created or cleaned up.","title":"Class Attributes"},{"location":"api/vaping.plugins/#class-attributes_3","text":"ConfigSchema ( PluginConfigSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins/#instanced-attributes_1","text":"These attributes / properties will be available on instances of the class config ( dict ): plugin config groups ( @property ): dict - group configurations keyed by name log ( @property ): logger instance for plugin type vaping: reference to the main vaping object","title":"Instanced Attributes"},{"location":"api/vaping.plugins/#methods_2","text":"","title":"Methods"},{"location":"api/vaping.plugins/#__init___2","text":"def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins/#init","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins/#new_message","text":"def new_message(self) creates and returns new message dict , setting type , source , ts , data data is initialized to an empty array Returns message ( dict )","title":"new_message"},{"location":"api/vaping.plugins/#on_start","text":"def on_start(self) called when the daemon is starting","title":"on_start"},{"location":"api/vaping.plugins/#on_stop","text":"def on_stop(self) called when the daemon is stopping","title":"on_stop"},{"location":"api/vaping.plugins/#popen","text":"def popen(self, args, **kwargs) creates a subprocess with passed args Returns Popen instance","title":"popen"},{"location":"api/vaping.plugins/#pluginconfigschema","text":"PluginConfigSchema(confu.schema.core.Schema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this.","title":"PluginConfigSchema"},{"location":"api/vaping.plugins/#class-attributes_4","text":"name ( Str Instance ): Plugin name type ( Str Instance ): Plugin type","title":"Class Attributes"},{"location":"api/vaping.plugins/#probebase","text":"ProbeBase(vaping.plugins.PluginBase) Base class for probe plugin, used for getting data expects method probe() to be defined","title":"ProbeBase"},{"location":"api/vaping.plugins/#methods_3","text":"","title":"Methods"},{"location":"api/vaping.plugins/#__init___3","text":"def __init__(self, config, ctx, emit=None) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins/#emit_all","text":"def emit_all(self) emit and remove all emissions in the queue","title":"emit_all"},{"location":"api/vaping.plugins/#init_1","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins/#probe_1","text":"def probe(self) probe for data, return a list of dicts","title":"probe"},{"location":"api/vaping.plugins/#queue_emission","text":"def queue_emission(self, msg) queue an emission of a message for all output plugins Arguments msg ( dict ): dict containing type , source , ts and data keys","title":"queue_emission"},{"location":"api/vaping.plugins/#send_emission","text":"def send_emission(self) emit and remove the first emission in the queue","title":"send_emission"},{"location":"api/vaping.plugins/#timeseriesdb","text":"TimeSeriesDB(vaping.plugins.EmitBase) Base interface for timeseries db storage plugins","title":"TimeSeriesDB"},{"location":"api/vaping.plugins/#config_1","text":"filename ( str ): database file name template field ( str ): field name to read the value from","title":"Config"},{"location":"api/vaping.plugins/#class-attributes_5","text":"ConfigSchema ( TimeSeriesDBSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins/#instanced-attributes_2","text":"These attributes / properties will be available on instances of the class field ( str ): fieeld name to read the value from filename ( str ): database file name template","title":"Instanced Attributes"},{"location":"api/vaping.plugins/#methods_4","text":"","title":"Methods"},{"location":"api/vaping.plugins/#__init___4","text":"def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins/#create","text":"def create(self, filename) Create database Arguments filename ( str ): database filename","title":"create"},{"location":"api/vaping.plugins/#emit_1","text":"def emit(self, message) emit to database Arguments message ( dict ): vaping message dict","title":"emit"},{"location":"api/vaping.plugins/#filename_formatters","text":"def filename_formatters(self, data, row) Returns a dict containing the various filename formatter values Values are gotten from the vaping data message as well as the currently processed row in the message Arguments data ( dict ): vaping message row ( dict ): vaping message data row Returns formatter variables ( dict )","title":"filename_formatters"},{"location":"api/vaping.plugins/#format_filename","text":"def format_filename(self, data, row) Returns a formatted filename using the template stored in self.filename Arguments data ( dict ): vaping message row ( dict ): vaping message data row Returns formatted version of self.filename ( str )","title":"format_filename"},{"location":"api/vaping.plugins/#get","text":"def get(self, filename, from_time, to_time) Retrieve data from database for the specified timespan Arguments filename ( str ): database filename from_time ( int ): epoch timestamp start to_time ( int ): epoch timestamp end","title":"get"},{"location":"api/vaping.plugins/#update","text":"def update(self, filename, time, value) Update database Arguments filename ( str ): database filename time ( int ): epoch timestamp value ( mixed )","title":"update"},{"location":"api/vaping.plugins/#timeseriesdbschema","text":"TimeSeriesDBSchema(vaping.plugins.PluginConfigSchema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this.","title":"TimeSeriesDBSchema"},{"location":"api/vaping.plugins/#class-attributes_6","text":"field ( Str Instance ): field name to read the value from filename ( Str Instance ): database file name template","title":"Class Attributes"},{"location":"api/vaping.plugins/#timedprobe","text":"TimedProbe(vaping.plugins.ProbeBase) Probe class that calls probe every config defined interval","title":"TimedProbe"},{"location":"api/vaping.plugins/#class-attributes_7","text":"ConfigSchema ( TimedProbeSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins/#methods_5","text":"","title":"Methods"},{"location":"api/vaping.plugins/#__init___5","text":"def __init__(self, config, ctx, emit=None) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins/#timedprobeschema","text":"TimedProbeSchema(vaping.plugins.PluginConfigSchema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this.","title":"TimedProbeSchema"},{"location":"api/vaping.plugins/#class-attributes_8","text":"interval ( Str Instance ):","title":"Class Attributes"},{"location":"api/vaping.plugins.rrd/","text":"vaping.plugins.rrd Classes RRDToolPlugin RRDToolPlugin(vaping.plugins.TimeSeriesDB) RRDTool plugin that allows vaping to persist data in a rrdtool database Class Attributes ConfigSchema ( RRDToolSchema Class ): Base plugin config schema Methods __init__ def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context create def create(self, filename) Create database Arguments filename ( str ): database filename init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code update def update(self, filename, time, value) Update database Arguments filename ( str ): database filename time ( int ): epoch timestamp value ( mixed ) RRDToolSchema RRDToolSchema(vaping.plugins.TimeSeriesDBSchema) Define a schema for FPing and also define defaults. Class Attributes archives ( List Instance ): data_sources ( List Instance ): step ( Int Instance ): Passed to rrd tool --step option.","title":"vaping.plugins.rrd"},{"location":"api/vaping.plugins.rrd/#vapingpluginsrrd","text":"","title":"vaping.plugins.rrd"},{"location":"api/vaping.plugins.rrd/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins.rrd/#rrdtoolplugin","text":"RRDToolPlugin(vaping.plugins.TimeSeriesDB) RRDTool plugin that allows vaping to persist data in a rrdtool database","title":"RRDToolPlugin"},{"location":"api/vaping.plugins.rrd/#class-attributes","text":"ConfigSchema ( RRDToolSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins.rrd/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins.rrd/#__init__","text":"def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins.rrd/#create","text":"def create(self, filename) Create database Arguments filename ( str ): database filename","title":"create"},{"location":"api/vaping.plugins.rrd/#init","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins.rrd/#update","text":"def update(self, filename, time, value) Update database Arguments filename ( str ): database filename time ( int ): epoch timestamp value ( mixed )","title":"update"},{"location":"api/vaping.plugins.rrd/#rrdtoolschema","text":"RRDToolSchema(vaping.plugins.TimeSeriesDBSchema) Define a schema for FPing and also define defaults.","title":"RRDToolSchema"},{"location":"api/vaping.plugins.rrd/#class-attributes_1","text":"archives ( List Instance ): data_sources ( List Instance ): step ( Int Instance ): Passed to rrd tool --step option.","title":"Class Attributes"},{"location":"api/vaping.plugins.vodka/","text":"vaping.plugins.vodka Functions probe_to_graphsrv def probe_to_graphsrv(probe) takes a probe instance and generates a graphsrv data group for it using the probe's config Classes VodkaPlugin VodkaPlugin(vaping.plugins.EmitBase) Plugin that emits to vodka data Class Attributes ConfigSchema ( VodkaSchema Class ): Base plugin config schema Methods emit def emit(self, message) accept message to emit init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code VodkaSchema VodkaSchema(vaping.plugins.PluginConfigSchema) Define a schema for FPing and also define defaults. Class Attributes apps ( Dict Instance ): data ( List Instance ): plugins ( List Instance ):","title":"vaping.plugins.vodka"},{"location":"api/vaping.plugins.vodka/#vapingpluginsvodka","text":"","title":"vaping.plugins.vodka"},{"location":"api/vaping.plugins.vodka/#functions","text":"","title":"Functions"},{"location":"api/vaping.plugins.vodka/#probe_to_graphsrv","text":"def probe_to_graphsrv(probe) takes a probe instance and generates a graphsrv data group for it using the probe's config","title":"probe_to_graphsrv"},{"location":"api/vaping.plugins.vodka/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins.vodka/#vodkaplugin","text":"VodkaPlugin(vaping.plugins.EmitBase) Plugin that emits to vodka data","title":"VodkaPlugin"},{"location":"api/vaping.plugins.vodka/#class-attributes","text":"ConfigSchema ( VodkaSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins.vodka/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins.vodka/#emit","text":"def emit(self, message) accept message to emit","title":"emit"},{"location":"api/vaping.plugins.vodka/#init","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins.vodka/#vodkaschema","text":"VodkaSchema(vaping.plugins.PluginConfigSchema) Define a schema for FPing and also define defaults.","title":"VodkaSchema"},{"location":"api/vaping.plugins.vodka/#class-attributes_1","text":"apps ( Dict Instance ): data ( List Instance ): plugins ( List Instance ):","title":"Class Attributes"},{"location":"api/vaping.plugins.whisper/","text":"vaping.plugins.whisper Classes WhisperPlugin WhisperPlugin(vaping.plugins.TimeSeriesDB) Whisper plugin that allows vaping to persist data in a whisper database Class Attributes ConfigSchema ( WhisperSchema Class ): Base plugin config schema Methods __init__ def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context create def create(self, filename) Create database Arguments filename ( str ): database filename get def get(self, filename, from_time, to_time=None) Retrieve data from database for the specified timespan Arguments filename ( str ): database filename from_time ( int ): epoch timestamp start to_time ( int ): epoch timestamp end update def update(self, filename, time, value) Update database Arguments filename ( str ): database filename time ( int ): epoch timestamp value ( mixed ) WhisperSchema WhisperSchema(vaping.plugins.TimeSeriesDBSchema) Define a schema for FPing and also define defaults. Class Attributes aggregation_method ( Str Instance ): retention ( List Instance ): sparse ( Bool Instance ): x_files_factor ( Float Instance ):","title":"vaping.plugins.whisper"},{"location":"api/vaping.plugins.whisper/#vapingpluginswhisper","text":"","title":"vaping.plugins.whisper"},{"location":"api/vaping.plugins.whisper/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins.whisper/#whisperplugin","text":"WhisperPlugin(vaping.plugins.TimeSeriesDB) Whisper plugin that allows vaping to persist data in a whisper database","title":"WhisperPlugin"},{"location":"api/vaping.plugins.whisper/#class-attributes","text":"ConfigSchema ( WhisperSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins.whisper/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins.whisper/#__init__","text":"def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins.whisper/#create","text":"def create(self, filename) Create database Arguments filename ( str ): database filename","title":"create"},{"location":"api/vaping.plugins.whisper/#get","text":"def get(self, filename, from_time, to_time=None) Retrieve data from database for the specified timespan Arguments filename ( str ): database filename from_time ( int ): epoch timestamp start to_time ( int ): epoch timestamp end","title":"get"},{"location":"api/vaping.plugins.whisper/#update","text":"def update(self, filename, time, value) Update database Arguments filename ( str ): database filename time ( int ): epoch timestamp value ( mixed )","title":"update"},{"location":"api/vaping.plugins.whisper/#whisperschema","text":"WhisperSchema(vaping.plugins.TimeSeriesDBSchema) Define a schema for FPing and also define defaults.","title":"WhisperSchema"},{"location":"api/vaping.plugins.whisper/#class-attributes_1","text":"aggregation_method ( Str Instance ): retention ( List Instance ): sparse ( Bool Instance ): x_files_factor ( Float Instance ):","title":"Class Attributes"},{"location":"api/vaping.plugins.zeromq/","text":"vaping.plugins.zeromq Classes ZeroMQ ZeroMQ(vaping.plugins.EmitBase) plugin to emit json encoded messages via zeromq Class Attributes ConfigSchema ( ZeroMQSchema Class ): Base plugin config schema Instanced Attributes These attributes / properties will be available on instances of the class ctx ( zmq Context ) sock ( zmq socket ) Methods __init__ def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context emit def emit(self, message) accept message to emit init def init(self) called after the plugin is initialized, plugin may define this for any other initialization code on_start def on_start(self) called when the daemon is starting on_stop def on_stop(self) called when the daemon is stopping ZeroMQSchema ZeroMQSchema(vaping.plugins.PluginConfigSchema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this. Class Attributes bind ( Str Instance ): connect ( Str Instance ):","title":"vaping.plugins.zeromq"},{"location":"api/vaping.plugins.zeromq/#vapingpluginszeromq","text":"","title":"vaping.plugins.zeromq"},{"location":"api/vaping.plugins.zeromq/#classes","text":"","title":"Classes"},{"location":"api/vaping.plugins.zeromq/#zeromq","text":"ZeroMQ(vaping.plugins.EmitBase) plugin to emit json encoded messages via zeromq","title":"ZeroMQ"},{"location":"api/vaping.plugins.zeromq/#class-attributes","text":"ConfigSchema ( ZeroMQSchema Class ): Base plugin config schema","title":"Class Attributes"},{"location":"api/vaping.plugins.zeromq/#instanced-attributes","text":"These attributes / properties will be available on instances of the class ctx ( zmq Context ) sock ( zmq socket )","title":"Instanced Attributes"},{"location":"api/vaping.plugins.zeromq/#methods","text":"","title":"Methods"},{"location":"api/vaping.plugins.zeromq/#__init__","text":"def __init__(self, config, ctx) Arguments config ( dict ) ctx: vaping context","title":"__init__"},{"location":"api/vaping.plugins.zeromq/#emit","text":"def emit(self, message) accept message to emit","title":"emit"},{"location":"api/vaping.plugins.zeromq/#init","text":"def init(self) called after the plugin is initialized, plugin may define this for any other initialization code","title":"init"},{"location":"api/vaping.plugins.zeromq/#on_start","text":"def on_start(self) called when the daemon is starting","title":"on_start"},{"location":"api/vaping.plugins.zeromq/#on_stop","text":"def on_stop(self) called when the daemon is stopping","title":"on_stop"},{"location":"api/vaping.plugins.zeromq/#zeromqschema","text":"ZeroMQSchema(vaping.plugins.PluginConfigSchema) Configuration Schema for PluginBase When creating new configuration schemas for extended plugins extend this.","title":"ZeroMQSchema"},{"location":"api/vaping.plugins.zeromq/#class-attributes_1","text":"bind ( Str Instance ): connect ( Str Instance ):","title":"Class Attributes"}]}